use std::{
    collections::{HashMap, HashSet},
    env, fs, io,
    path::Path,
};

use proc_macro2::{Delimiter, TokenTree};

fn walk_dir<P: AsRef<Path>>(path: P, trees: &mut InheritanceTrees) -> Result<(), io::Error> {
    for dir_entry_or_error in fs::read_dir(path)? {
        let dir_entry = dir_entry_or_error?;

        if dir_entry.file_type()?.is_file() {
            process_file(dir_entry.path(), trees)?;
        } else {
            println!("cargo:warning=Found directory {}, files in subdirectories are NOT considered by the inheritance system!", dir_entry.path().display())
        }
    }
    Ok(())
}

fn process_file<P: AsRef<Path>>(path: P, trees: &mut InheritanceTrees) -> Result<(), io::Error> {
    let file_contents = fs::read_to_string(path)?;
    let ast = syn::parse_file(&file_contents).unwrap();

    for item in ast.items {
        if let syn::Item::Struct(struct_def) = item {
            // Check if the struct defines an "inherit" attribute
            let mut inherits_from = None;
            for attr in struct_def.attrs {
                if let Some(ident) = attr.path.get_ident() {
                    if ident == "inherit" {
                        if attr.tokens.is_empty() {
                            // This is a root object, it does not inherit from anything but the type system
                            // still needs to know about it
                            trees.types.insert(struct_def.ident.to_string());
                            break;
                        }

                        let mut tokens = attr.tokens.into_iter();
                        let group = match tokens.next() {
                            Some(TokenTree::Group(group))
                                if group.delimiter() == Delimiter::Parenthesis =>
                            {
                                group
                            },
                            _ => panic!("Invalid inherit attribute"),
                        };

                        let mut argument_tokens = group.stream().into_iter();
                        let parent_type_name = match argument_tokens.next() {
                            Some(TokenTree::Ident(ident)) => ident,

                            _ => panic!("Invalid inherit attribute"),
                        };
                        if argument_tokens.next().is_some() {
                            panic!("Invalid inherit attribute, are you trying to specify a full path (like foo::bar)? Because that's not allowed.")
                        }

                        inherits_from = Some(parent_type_name.to_string());
                        break;
                    }
                }
            }

            if let Some(parent_name) = inherits_from {
                let struct_name = struct_def.ident.to_string();
                if !trees.types.insert(struct_name.clone()) {
                    panic!("{struct_name:?} was declared twice");
                }

                trees
                    .children
                    .entry(parent_name)
                    .or_default()
                    .push(struct_name);
            }
        }
    }

    Ok(())
}

#[derive(Default, Debug)]
struct InheritanceTrees {
    types: HashSet<String>,
    /// Mapping from parent type -> types that inherit from it
    children: HashMap<String, Vec<String>>,
}

fn main() -> Result<(), io::Error> {
    println!("cargo:rerun-if-changed=src/dom_objects");

    let mut hierarchy = InheritanceTrees::default();
    walk_dir("src/dom_objects", &mut hierarchy)?;

    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("inheritance_autogenerated.rs");

    let typenames = hierarchy
        .types
        .iter()
        .cloned()
        .collect::<Vec<String>>()
        .join(",");

    let autogenerated_code = format!(
        "
        pub enum DOMType {{
            {typenames}
        }}
        "
    );
    fs::write(dest_path, autogenerated_code)?;

    Ok(())
}
